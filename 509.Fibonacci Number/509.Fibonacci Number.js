/*
解题思路：动态规划（自上而下,从目标往前推，边走边看，用到什么计算什么）
注意：大部分动态规划问题解法 -> 递归(recursion) + 记忆化(memoization)
递归的问题：大量重复的计算会导致时间复杂度指数级增加
引入记忆化：在递归的基础上，去记住、缓存住一些之前计算过的值，避免递归重复计算

1、边界条件预判，如果N为0或者1，说明是前两个数，直接返回N就行
2、创建记忆化数组，缓存一些重复计算的结果，需要用的时候直接来取，不用重复计算了
3、已知前两个数，直接放进来
4、创建递归的函数，递归计算的中间结果全部存放到记忆化数组中：
    4.1、如果输入的第n个斐波那契数已经在记忆数组中了，就直接返回，不用再算了
    4.2、否则，自上而下递归计算该斐波那契数，同时存放在记忆数组中
    4.3、返回保存在记忆数组中的该斐波那契数
5、调用上述递归函数
6、返回结果
*/
/**
 * @param {number} N
 * @return {number}
 */
var fib = function (N) {
  // 1、边界条件预判，如果N为0或者1，说明是前两个数，直接返回N就行
  if (N <= 1) {
    return N;
  }

  // 2、创建记忆化数组，缓存一些重复计算的结果，需要用的时候直接来取，不用重复计算了
  const memo = [];

  // 3、已知前两个数，直接放进来
  memo[0] = 0;
  memo[1] = 1;

  // 4、创建递归的函数，递归计算的中间结果全部存放到记忆化数组中：
  function helper(n) {
    // 4.1、如果输入的第n个斐波那契数已经在记忆数组中了，就直接返回，不用再算了
    if (memo[n] !== undefined) {
      return memo[n];
    }

    // 4.2、否则，自上而下递归计算该斐波那契数，同时存放在记忆数组中
    memo[n] = helper(n - 1) + helper(n - 2);

    // 4.3、返回保存在记忆数组中的该斐波那契数
    return memo[n];
  }

  // 5、调用依次上述递归函数
  const result = helper(N);
  // 6、返回结果
  return result;
};
