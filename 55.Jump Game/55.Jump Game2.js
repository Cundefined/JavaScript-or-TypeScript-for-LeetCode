/*
解题思路：动态规划、贪心算法
方法二、动态规划【自下而上,结尾到开头】
1、创建记录标记当前元素是否为通的memo数组，标记：0未知，-1不通，1可通,初始化为全0
2、将最后一个元素标记为1，因为是终点嘛，肯定可以通过
3、从输入数组的倒数第二个元素（因为最后一个已经标记为1了）往前遍历每个元素:
    3.1、计算最大跳跃距离，取当前位置+当前位置数字和输入数组最大索引的最小值，从而防止越界
    3.2、开始跳！从当前位置下一个位置遍历到最大跳跃距离的每一个元素：
        3.2.1、一旦调到一个标记为1的元素上，就把当前元素标记为1，退出循环
4、从结尾遍历到开头完成之后，检查起点是否被标为1，是的话，说明可以从起点到终点
*/

/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function (nums) {
  // 1、创建记录标记当前元素是否为通的memo数组，标记：0未知，-1不通，1可通,初始化为全0
  const memo = Array(nums.length).fill(0);
  // 2、将最后一个元素标记为1，因为是终点嘛，肯定可以通过
  memo[nums.length - 1] = 1;

  // 3、从输入数组的倒数第二个元素（因为最后一个已经标记为1了）往前遍历每个元素:
  for (let i = nums.length - 2; i >= 0; i--) {
    //  3.1、计算最大跳跃距离，取当前位置+当前位置数字和输入数组最大索引的最小值，从而防止越界
    const MaxJumpDistance = Math.min(i + nums[i], nums.length - 1);
    // 3.2、开始跳！从当前位置下一个位置遍历到最大跳跃距离的每一个元素：
    for (let j = i + 1; j <= MaxJumpDistance; j++) {
      // 3.2.1、一旦调到一个标记为1的元素上，就把当前元素标记为1，退出循环
      if (memo[j] === 1) {
        memo[i] = 1;
        break;
      }
    }
  }

  // 4、从结尾遍历到开头完成之后，检查起点是否被标为1，是的话，说明可以从起点到终点
  if (memo[0] === 1) {
    return true;
  } else {
    return false;
  }
};
