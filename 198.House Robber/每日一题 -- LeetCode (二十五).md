# JavaScript / TypeScript for LeetCode 
**当前进程：**

 - 开始时间：2020.6.27 
 - 结束时间：undefined

***GitHub仓库：https://github.com/Cundefined/JavaScript-or-TypeScript-for-LeetCode***

***参考视频：https://www.bilibili.com/video/BV1wA411b7qZ***

## 1、题目要求
**( LeetCode-第198题 )  打家劫舍**
       你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。


​	  **示例 1:**

```javascript
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
**示例 2:**
```javascript
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/house-robber
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 2、解题思路
解题思路：动态规划

 1. 边界条件预判：
 	  1.1、输入数组为空，返回0
    1.2、输入数组长度为1，返回该元素
 2. 创建记忆数组，记录到达第i个房屋时，可以抢到的最大金额
 3. 手动添加前两个房屋可以抢的最大金额：
    3.1、第一个房屋，只能抢它，莫得选择
    3.2、第二个房屋，可以抢当前房屋或者抢第一个房屋，比较取较大者
 4. 到了第三个往后所有房屋，都有两种选择，for循环依次遍历，处理选择：
    4.1、memo[i]表示到达当前房屋可以抢的最大金额
    4.2、第一种选择：抢当前的房屋并且加上之前在第i-2房屋可以抢的最大金额
    4.3、第二种选择：不抢当前的房屋，直接看看在第i-1的房屋最大金额是多少
    4.4、两种选择取个最大值就是当前房屋可以抢到的最大金额
 5. 遍历完成后，返回劫匪达到最后一个房屋可以抢到的累计金额即为最大值

### 2.1、JavaScript Solution

```javascript
/*
解题思路：动态规划
1、边界条件预判：
    1.1、输入数组为空，返回0
    1.2、输入数组长度为1，返回该元素
2、创建记忆数组，记录到达第i个房屋时，可以抢到的最大金额
3、手动添加前两个房屋可以抢的最大金额：
    3.1、第一个房屋，只能抢它，莫得选择
    3.2、第二个房屋，可以抢当前房屋或者抢第一个房屋，比较取较大者
4、到了第三个往后所有房屋，都有两种选择，for循环依次遍历，处理选择：
    4.1、memo[i]表示到达当前房屋可以抢的最大金额
    4.2、第一种选择：抢当前的房屋并且加上之前在第i-2房屋可以抢的最大金额
    4.3、第二种选择：不抢当前的房屋，直接看看在第i-1的房屋最大金额是多少
    4.4、两种选择取个最大值就是当前房屋可以抢到的最大金额
5、遍历完成后，返回劫匪达到最后一个房屋可以抢到的累计金额即为最大值
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  // 1、边界条件预判：
  //   1.1、输入数组为空，返回0
  if (nums.length === 0) {
    return 0;
  }
  //   1.2、输入数组长度为1，返回该元素
  if (nums.length === 1) {
    return nums[0];
  }

  // 2、创建记忆数组，记录到达第i个房屋时，可以抢到的最大金额
  let memo = [];

  // 3、手动添加前两个房屋可以抢的最大金额：
  //   3.1、第一个房屋，只能抢它，莫得选择
  memo[0] = nums[0];
  //   3.2、第二个房屋，可以抢当前房屋或者抢第一个房屋，比较取较大者
  memo[1] = Math.max(nums[1], nums[0]);

  // 4、到了第三个往后所有房屋，都有两种选择，for循环依次遍历，处理选择：
  for (let i = 2; i < nums.length; i++) {
    // 4.1、memo[i]表示到达当前房屋可以抢的最大金额
    memo[i] = Math.max(nums[i] + memo[i - 2], memo[i - 1]);
  }

  // 5、遍历完成后，返回劫匪达到最后一个房屋可以抢到的累计金额即为最大值
  return memo[nums.length - 1];
};
```


### 2.2、TypeScript Solution

```javascript
function rob(nums: number[]): number {
    if (nums.length === 0) {
        return 0;
    }

    if (nums.length === 1) {
        return nums[0];
    }

    // 这里可以不创建记忆数组，只需要创建两个变量即可，优化空间复杂度
    // prev2表示在当前房屋的前前个房屋可以抢到的最大金额
    // prev1表示在当前房屋的前一个房屋可以抢到的最大金额
    let prev2: number = nums[0];
    let prev1: number = Math.max(nums[1], nums[0]);

    for (let i: number = 2; i < nums.length; i++) {
        let temp: number = Math.max(nums[i] + prev2, prev1);
        prev2 = prev1;
        prev1 = temp;
    }

    return prev1;
};
```

