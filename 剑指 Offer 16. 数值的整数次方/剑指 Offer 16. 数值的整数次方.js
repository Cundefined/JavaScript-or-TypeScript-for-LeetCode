/*
解题思路：快速幂算法
例如：求a的11次
11 = (1011)b = 2的3次 * 1 + 2的2次 * 1 + 2的1次 * 1 + 2的0次 * 1
a的11次 = （a的8次 * 1） * （a的4次 * 0）* （a的2次 * 1）* （a的0次 * 1）
注意：二进制的每一位控制是否需要把a的次方乘进最后的结果中
    所以，关键在于判断每一位是否为1，为1就乘如，不为1就不乘入，只需要把幂的二进制右移一位继续判断
*/
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function (x, n) {
  // 边界条件
  if (x === 0) {
    return 0;
  }

  let res = 1.0;

  // 幂为负时，需要倒一下，转换成(1/x)的正n次方
  if (n < 0) {
    n = -n;
    x = 1 / x;
  }

  //循环移位n的二进制，从最右边依次往左边判断每一位是否为1
  while (n > 0) {
    if ((n & 1) === 1) {
      res = res * x;
    }

    x = x * x;

    n = n >>> 1;
  }

  return res;
};
